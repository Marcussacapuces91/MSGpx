/*
    Copyright © 2010 par Marc Sibert

    This file is part of LIBOSM

    LIBOSM is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    LIBOSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with LIBOSM.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file
 * \author Marc Sibert
 */

// Class automatically generated by Dev-C++ New Class wizard

#include "point.h" // class's header file
#include <cmath>

#ifndef M_PI
/// Valeur de PI. Constante non dispo en C++ ANSI, sinon définie dans math.h.
#define M_PI 3.14159265358979323846L
#endif

/// Rayon moyen de la Terre.
const double Point::RAYON_TERRE = 6371000.0;

Point& Point::operator=(const Point& aPoint)
{
//    if (this == &aPoint) return *this;  // Cas de l'auto-affectation : sans danger.
    fLatitude = aPoint.fLatitude;
    fLongitude = aPoint.fLongitude;
    return *this;
}

double Point::distance(const Point& aPoint) const
{

    const double dLat = (aPoint.fLatitude - fLatitude) * M_PI / 180.0;
    const double dLon = (aPoint.fLongitude - fLongitude)* M_PI / 180.0;
    const double a = pow(sin(dLat / 2.0), 2) +
                     (cos(aPoint.fLatitude * M_PI / 180.0) * cos(fLatitude * M_PI / 180.0)) *
                     pow(sin(dLon / 2.0), 2);
    const double c = 2 * atan2(sqrt(a), sqrt(1-a));
    return c * RAYON_TERRE;
}

bool Point::operator==(const Point& aPoint)
{
    return (&aPoint == this) ||
           ((aPoint.fLatitude == fLatitude) &&
            (aPoint.fLongitude == fLongitude));
}


Point Point::decaller(const double& aDistance, const float& aBearing) const
{
    const double r = aDistance / RAYON_TERRE;
    const double lat1 = fLatitude * M_PI / 180.0;
    const double lon1 = fLongitude * M_PI / 180.0;
    const double brng = aBearing * M_PI / 180.0;

    const double lat2 = asin(sin(lat1) * cos(r) +
                             cos(lat1) * sin(r) * cos(brng));
    const double lon2 = lon1 + atan2(sin(brng) * sin(r) * cos(lat1),
                                     cos(r) - sin(lat1) * sin(lat2));

    return Point(lat2 * 180.0 / M_PI, lon2 * 180.0 / M_PI);
}


float Point::bearing(const Point& aPoint) const
{
    const double lat1 = fLatitude * M_PI / 180.0;
    const double lat2 = aPoint.fLatitude * M_PI / 180.0;
//    const double lon2 = aPoint.fLongitude * M_PI / 180.0;

    const double dLon = (aPoint.fLongitude - fLongitude) * M_PI / 180.0;

    const double y = sin(dLon) * cos(lat2);
    const double x = cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(dLon);
    return atan2(y, x) * 180.0 / M_PI;
}

